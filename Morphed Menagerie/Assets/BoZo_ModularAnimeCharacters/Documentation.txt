Thank you for purchasing BoZo Modular Anime Characters!

Any Feedback Bugs or if you need help please email me at: Druelbozo@gmail.com


Documentation:
https://docs.google.com/document/d/1kf1KGT-OqV3Ecvnej0mpmgIOkc-_e7UJp-BkGuZfuN4/edit?usp=sharing




        Pass
        {
            Name "Outline"
            Tags { "LightMode" = "UniversalForward" "RenderType"="TransparentCutout" "Queue"="AlphaTest" }
            Cull Front
            ZWrite On

            HLSLPROGRAM
            #pragma vertex vert
#pragma fragment frag
# include "Packages/com.unity.render-pipelines.universal/ShaderLibrary/Core.hlsl"

            struct Attributes
{
    float4 positionOS : POSITION;
                float3 normalOS : NORMAL;
                float4 color : COLOR; 
                float2 uv: TEXCOORD0;
            };

struct Varyings
{
    float4 positionHCS : SV_POSITION;
                float4 color : COLOR;
                float2 uv: TEXCOORD0;
            };

TEXTURE2D(_MaskMap);
SAMPLER(sampler_MaskMap);
float _OutlineDistance;
float4 _OutlineColor;

float _MaskEdgeHigh_1;
float _MaskEdgeHigh_2;
float _MaskEdgeHigh_3;
float _MaskEdgeHigh_4;
float _MaskEdgeHigh_5;
float _MaskEdgeHigh_6;

float _MaskEdgeLow_1;
float _MaskEdgeLow_2;
float _MaskEdgeLow_3;
float _MaskEdgeLow_4;
float _MaskEdgeLow_5;
float _MaskEdgeLow_6;
float _UseMaskMap;


Varyings vert(Attributes IN)
{
    Varyings OUT;
    float3 norm = normalize(IN.normalOS);
    float3 pos = IN.positionOS.xyz + norm * (_OutlineDistance * 0.001) * IN.color.w;
    OUT.positionHCS = TransformObjectToHClip(pos);
    OUT.uv = IN.uv;
    return OUT;
}

half4 frag(Varyings IN) : SV_Target
            {
                float4 maskTex = SAMPLE_TEXTURE2D(_MaskMap, sampler_MaskMap, IN.uv);



float highMask1 = step(_MaskEdgeHigh_1, maskTex.r);
float highMask2 = step(_MaskEdgeHigh_2, maskTex.g);
float highMask3 = step(_MaskEdgeHigh_3, maskTex.b);
float highMask4 = step(_MaskEdgeHigh_4, maskTex.r);
float highMask5 = step(_MaskEdgeHigh_5, maskTex.g);
float highMask6 = step(_MaskEdgeHigh_6, maskTex.b);

float lowMask1 = step(_MaskEdgeLow_1, 1 - maskTex.r);
float lowMask2 = step(_MaskEdgeLow_2, 1 - maskTex.g);
float lowMask3 = step(_MaskEdgeLow_3, 1 - maskTex.b);
float lowMask4 = step(_MaskEdgeLow_4, 1 - maskTex.r);
float lowMask5 = step(_MaskEdgeLow_5, 1 - maskTex.g);
float lowMask6 = step(_MaskEdgeLow_6, 1 - maskTex.b);

float mask1 = highMask1 * lowMask1;
float mask2 = highMask2 * lowMask2;
float mask3 = highMask3 * lowMask3;
float mask4 = highMask4 * lowMask4;
float mask5 = highMask5 * lowMask5;
float mask6 = highMask6 * lowMask6;

float fullAlphaMask = mask1 + mask2 + mask3;
float nullAlphaMask = mask4 + mask5 + mask6;

float4 mask = lerp(nullAlphaMask, fullAlphaMask, maskTex.a);

float4 finalMask = lerp(1, mask, _UseMaskMap);

clip(finalMask - 0.5);



return _OutlineColor * finalMask;
            }
            ENDHLSL